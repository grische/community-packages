#!/usr/bin/lua

local unistd = require 'posix.unistd'
local util = require 'gluon.util'
local site = require 'gluon.site'
local log = require 'posix.syslog'

local function logger(dest, msg)
	local prefix = 'ffac-scheduled-sysupgrade: '
	msg = prefix .. msg
	if dest == 'out' then
		io.stdout:write(msg .. '\n')
		log.syslog(log.LOG_INFO, msg)
	elseif dest == 'err' then
		io.stderr:write(msg .. '\n')
		log.syslog(log.LOG_CRIT, msg)
	end
end

function os.capture(cmd, raw)
	local f = assert(io.popen(cmd, 'r'))
	local s = assert(f:read('*a'))
	f:close()
	if raw then return s end
	s = string.gsub(s, '^%s+', '')
	s = string.gsub(s, '%s+$', '')
	s = string.gsub(s, '[\n\r]+', ' ')
	return s
end

-- Returns true if firmware was downloaded long enough ago to perform domain switch
local function switch_after_min_reached()
	if not unistd.access("/tmp/firmware_available") then
		logger("out", "/tmp/firmware_available unavailable 1")
		return false
	end

	local switch_after_sec = site.scheduled_sysupgrade.switch_after_existing_mins() * 60

	local current_uptime = util.get_uptime()
	if current_uptime == nil then
		logger("out", "Uptime unavailable")
		return false
	end

	local f = util.readfile("/tmp/firmware_available")
	if f == nil then
		logger("out", "/tmp/firmware_available unavailable 2")
		return false
	end
	local firmware_available_since = tonumber(f)

	local firmware_available_time_sec = current_uptime - firmware_available_since

	logger("out", "firmware_available_time_sec = " .. tostring(current_uptime) .. " - " .. tostring(firmware_available_since))
	if firmware_available_time_sec > switch_after_sec then
		logger("out", "switch_after_min_reached() true: firmware_available_time_sec > " .. tostring(switch_after_sec))
		return true
	end
	return false
end

-- Returns true if node was offline long enough to perform domain switch
local function switch_after_min_offline()
	-- /tmp/gluon_offline generated by scheduled-domain-switch
	if not unistd.access("/tmp/gluon_offline") then
		logger("out", "/tmp/gluon_offline unavailable 1")
		return false
	end

	local switch_after_min = site.scheduled_sysupgrade.switch_after_offline_mins()
	if not switch_after_min then
		-- field not set in site
		return false
	end
	local switch_after_sec = switch_after_min * 60

	local current_uptime = util.get_uptime()
	if current_uptime == nil then
		logger("out", "Uptime unavailable (offline)")
		return false
	end

	local f = util.readfile("/tmp/gluon_offline")
	if f == nil then
		logger("out", "/tmp/gluon_offline unavailable 2")
		return false
	end
	local offline_since = tonumber(f)

	local offline_time_sec = current_uptime - offline_since

	logger("out", "offline_time_sec = " .. tostring(current_uptime) .. " - " .. tostring(offline_since))
	if offline_time_sec > switch_after_sec then
		logger("out", "switch_after_min_reached() true: offline_time_sec > " .. tostring(switch_after_sec))
		return true
	end
	logger("out", "switch_after_min_reached() final false")
	return false
end

-- Returns true in case switch time has passed
local function switch_time_passed()
	local current_time = os.time()
	local switch_time = site.scheduled_sysupgrade.switch_time()

	logger("out", "switch_time_passed() " .. tostring(switch_time) .. " < " .. tostring(current_time))
	return switch_time < current_time
end

if site.scheduled_sysupgrade() == nil then
	-- Switch not applicable
	logger("out", "No schedule for sysupgrade")
	os.exit(0)
end

if not switch_time_passed()
	and not switch_after_min_reached()
	and not switch_after_min_offline()
then
	logger("out", "Neither switch-time passed nor switch_after_min reached")
	os.exit(0)
end

local success = os.execute("sysupgrade --ignore-minor-compat-version /tmp/firmware.bin")

if success > 0 then
	logger("out", "Failed to run with --ignore-minor-compat-version, trying to run without")
	logger("err", os.capture("sysupgrade /tmp/firmware.bin"))
end
